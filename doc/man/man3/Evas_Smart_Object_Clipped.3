.TH "Clipped Smart Object" 3 "Tue Apr 19 2011" "Evas" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Clipped Smart Object \- 
.PP
Clipped smart object is a base to construct other smart objects that based on the concept of having an internal clipper that is applied to all its other children.  

.SS "Functions"

.in +1c
.ti -1c
.RI "EAPI void \fBevas_object_smart_move_children_relative\fP (\fBEvas_Object\fP *obj, Evas_Coord dx, Evas_Coord dy)"
.br
.RI "\fIMoves all children objects relative to given offset. \fP"
.ti -1c
.RI "EAPI \fBEvas_Object\fP * \fBevas_object_smart_clipped_clipper_get\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fIGet the clipper object for the given clipped smart object. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_smart_clipped_smart_set\fP (\fBEvas_Smart_Class\fP *sc)"
.br
.RI "\fISet smart class callbacks so it implements the 'Clipped Smart Object'. \fP"
.ti -1c
.RI "EAPI const \fBEvas_Smart_Class\fP * \fBevas_object_smart_clipped_class_get\fP (void)"
.br
.RI "\fIGet a pointer to the Clipped Smart Class to use for proper inheritance. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Clipped smart object is a base to construct other smart objects that based on the concept of having an internal clipper that is applied to all its other children. 

This clipper will control the visibility, clipping and color of sibling objects (remember that the clipping is recursive, and clipper color modulates the color of its clippees). By default, this base will also move children relatively to the parent, and delete them when parent is deleted. In other words, it is the base for simple object grouping.
.PP
\fBSee also:\fP
.RS 4
\fBevas_object_smart_clipped_smart_set()\fP 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "EAPI \fBEvas_Object\fP* evas_object_smart_clipped_clipper_get (\fBEvas_Object\fP * obj)"
.PP
Get the clipper object for the given clipped smart object. \fBParameters:\fP
.RS 4
\fIobj\fP the clipped smart object to retrieve the associated clipper. 
.RE
.PP
\fBReturns:\fP
.RS 4
the clipper object.
.RE
.PP
\fBSee also:\fP
.RS 4
evas_object_smart_clipped_smart_add() 
.RE
.PP

.PP
References evas_object_smart_data_get().
.SS "EAPI void evas_object_smart_clipped_smart_set (\fBEvas_Smart_Class\fP * sc)"
.PP
Set smart class callbacks so it implements the 'Clipped Smart Object'. This call will assign all the required methods of Evas_Smart_Class, if one wants to 'subclass' it, call this function and later override values, if one wants to call the original method, save it somewhere, example:
.PP
.PP
.nf
 static Evas_Smart_Class parent_sc = EVAS_SMART_CLASS_INIT_NULL;

 static void my_class_smart_add(Evas_Object *o)
 {
    parent_sc.add(o);
    evas_object_color_set(evas_object_smart_clipped_clipper_get(o),
                          255, 0, 0, 255);
 }

 Evas_Smart_Class *my_class_new(void)
 {
    static Evas_Smart_Class sc = EVAS_SMART_CLASS_INIT_NAME_VERSION('MyClass');
    if (!parent_sc.name)
      {
         evas_object_smart_clipped_smart_set(&sc);
         parent_sc = sc;
         sc.add = my_class_smart_add;
      }
    return &sc;
 }
.fi
.PP
.PP
Default behavior is:
.IP "\(bu" 2
add: creates a hidden clipper with 'infinite' size;
.IP "\(bu" 2
del: delete all children objects;
.IP "\(bu" 2
move: move all objects relative relatively;
.IP "\(bu" 2
resize: not defined;
.IP "\(bu" 2
show: if there are children objects, show clipper;
.IP "\(bu" 2
hide: hides clipper;
.IP "\(bu" 2
color_set: set the color of clipper;
.IP "\(bu" 2
clip_set: set clipper of clipper;
.IP "\(bu" 2
clip_unset: unset the clipper of clipper; 
.PP

.PP
Referenced by evas_object_smart_clipped_class_get().
.SS "EAPI void evas_object_smart_move_children_relative (\fBEvas_Object\fP * obj, Evas_Coord dx, Evas_Coord dy)"
.PP
Moves all children objects relative to given offset. \fBParameters:\fP
.RS 4
\fIobj\fP the smart evas object to use. 
.br
\fIdx\fP horizontal offset. 
.br
\fIdy\fP vertical offset. 
.RE
.PP

.PP
References evas_object_move().
.SH "Author"
.PP 
Generated automatically by Doxygen for Evas from the source code.
