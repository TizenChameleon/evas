.TH "Basic Object Manipulation" 3 "Tue Apr 19 2011" "Evas" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Basic Object Manipulation \- 
.PP
Methods that are often used, like those that change the color, clippers and geometry of the object.  

.SS "Functions"

.in +1c
.ti -1c
.RI "EAPI void \fBevas_object_clip_set\fP (\fBEvas_Object\fP *obj, \fBEvas_Object\fP *clip)"
.br
.RI "\fIClip one object to another. \fP"
.ti -1c
.RI "EAPI \fBEvas_Object\fP * \fBevas_object_clip_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIGet the object clipping this one (if any). \fP"
.ti -1c
.RI "EAPI void \fBevas_object_clip_unset\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fIDisable clipping for an object. \fP"
.ti -1c
.RI "EAPI const Eina_List * \fBevas_object_clipees_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIReturn a list of objects currently clipped by a specific object. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_focus_set\fP (\fBEvas_Object\fP *obj, Eina_Bool focus)"
.br
.RI "\fISets focus to the given object. \fP"
.ti -1c
.RI "EAPI Eina_Bool \fBevas_object_focus_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fITest if the object has focus. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_layer_set\fP (\fBEvas_Object\fP *obj, short l)"
.br
.RI "\fISets the layer of the evas that the given object will be part of. \fP"
.ti -1c
.RI "EAPI short \fBevas_object_layer_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIRetrieves the layer of the evas that the given object is part of. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_name_set\fP (\fBEvas_Object\fP *obj, const char *name)"
.br
.RI "\fISets the name of the given evas object to the given name. \fP"
.ti -1c
.RI "EAPI const char * \fBevas_object_name_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIRetrieves the name of the given evas object. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_ref\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fIIncrements object reference count to defer deletion. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_unref\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fIDecrements object reference count to defer deletion. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_del\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fIDeletes the given evas object and frees its memory. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_move\fP (\fBEvas_Object\fP *obj, Evas_Coord x, Evas_Coord y)"
.br
.RI "\fIMoves the given evas object to the given location. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_resize\fP (\fBEvas_Object\fP *obj, Evas_Coord w, Evas_Coord h)"
.br
.RI "\fIChanges the size of the given evas object. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_geometry_get\fP (const \fBEvas_Object\fP *obj, Evas_Coord *x, Evas_Coord *y, Evas_Coord *w, Evas_Coord *h)"
.br
.RI "\fIRetrieves the position and rectangular size of the given evas object. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_show\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fIMakes the given evas object visible. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_hide\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fIMakes the given evas object invisible. \fP"
.ti -1c
.RI "EAPI Eina_Bool \fBevas_object_visible_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIRetrieves whether or not the given evas object is visible. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_color_set\fP (\fBEvas_Object\fP *obj, int r, int g, int b, int a)"
.br
.RI "\fISets the general colour of the given evas object to the given colour. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_color_get\fP (const \fBEvas_Object\fP *obj, int *r, int *g, int *b, int *a)"
.br
.RI "\fIRetrieves the general colour of the given evas object. \fP"
.ti -1c
.RI "EAPI \fBEvas\fP * \fBevas_object_evas_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIRetrieves the evas that the given evas object is on. \fP"
.ti -1c
.RI "EAPI const char * \fBevas_object_type_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIRetrieves the name of the type of the given evas object. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_raise\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fIRaise \fCobj\fP to the top of its layer. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_lower\fP (\fBEvas_Object\fP *obj)"
.br
.RI "\fILower \fCobj\fP to the bottom of its layer. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_stack_above\fP (\fBEvas_Object\fP *obj, \fBEvas_Object\fP *above)"
.br
.RI "\fIStack \fCobj\fP immediately above \fCabove\fP. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_stack_below\fP (\fBEvas_Object\fP *obj, \fBEvas_Object\fP *below)"
.br
.RI "\fIStack \fCobj\fP immediately below \fCbelow\fP. \fP"
.ti -1c
.RI "EAPI \fBEvas_Object\fP * \fBevas_object_above_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIGet the evas object above \fCobj\fP. \fP"
.ti -1c
.RI "EAPI \fBEvas_Object\fP * \fBevas_object_below_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIGet the evas object below \fCobj\fP. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Methods that are often used, like those that change the color, clippers and geometry of the object. 
.SH "Function Documentation"
.PP 
.SS "EAPI \fBEvas_Object\fP* evas_object_above_get (const \fBEvas_Object\fP * obj)"
.PP
Get the evas object above \fCobj\fP. \fBParameters:\fP
.RS 4
\fIobj\fP an Evas_Object 
.RE
.PP
\fBReturns:\fP
.RS 4
the Evas_Object directly above 
.RE
.PP

.SS "EAPI \fBEvas_Object\fP* evas_object_below_get (const \fBEvas_Object\fP * obj)"
.PP
Get the evas object below \fCobj\fP. \fBParameters:\fP
.RS 4
\fIobj\fP an Evas_Object 
.RE
.PP
\fBReturns:\fP
.RS 4
the Evas_Object directly below 
.RE
.PP

.SS "EAPI \fBEvas_Object\fP* evas_object_clip_get (const \fBEvas_Object\fP * obj)"
.PP
Get the object clipping this one (if any). \fBParameters:\fP
.RS 4
\fIobj\fP The object to get the clipper from
.RE
.PP
This function returns the the object clipping \fCobj\fP. If \fCobj\fP not being clipped, NULL is returned. The object \fCobj\fP must be a valid object.
.PP
See also \fBevas_object_clip_set()\fP, \fBevas_object_clip_unset()\fP and \fBevas_object_clipees_get()\fP.
.PP
Example: 
.PP
.nf
 extern Evas_Object *obj;
 Evas_Object *clipper;

 clipper = evas_object_clip_get(obj);
 if (clipper) evas_object_show(clipper);

.fi
.PP
 
.SS "EAPI void evas_object_clip_set (\fBEvas_Object\fP * obj, \fBEvas_Object\fP * clip)"
.PP
Clip one object to another. \fBParameters:\fP
.RS 4
\fIobj\fP The object to be clipped 
.br
\fIclip\fP The object to clip \fCobj\fP by
.RE
.PP
This function will clip the object \fCobj\fP to the area occupied by the object \fCclipper\fP. This means the object \fCobj\fP will only be visible within the area occupied by the clipping object (\fCclip\fP). The color of the object being clipped will be multiplied by the color of the clipping object, so the resulting color for the clipped object is RESULT = (OBJ * CLIP) / (255 * 255) per color element (red, green, blue and alpha). Clipping is recursive, so clip objects may be clipped by other objects, and their color will in tern be multiplied. You may NOT set up circular clipping lists (i.e. object 1 clips object 2 which clips object 1). The behavior of Evas is undefined in this case. Objects which do not clip others are visible as normal, those that clip 1 or more objects become invisible themselves, only affecting what they clip. If an object ceases to have other objects being clipped by it, it will become visible again. The visibility of an object affects the objects that are clipped by it, so if the object clipping others is not shown, the objects clipped will not be shown either. If the object was being clipped by another object when this function is called, it is implicitly removed from the clipper it is being clipped to, and now is made to clip its new clipper.
.PP
At the moment the only objects that can validly be used to clip other objects are rectangle objects. All other object types are invalid and the result of using them is undefined.
.PP
The clip object \fCclip\fP must be a valid object, but may also be NULL in which case the effect of this function is the same as calling \fBevas_object_clip_unset()\fP on the \fCobj\fP object.
.PP
Example: 
.PP
.nf
 extern Evas *evas;
 extern Evas_Object *obj;
 Evas_Object *clipper;

 clipper = evas_object_rectangle_add(evas);
 evas_object_color_set(clipper, 255, 255, 255, 255);
 evas_object_move(clipper, 10, 10);
 evas_object_resize(clipper, 20, 50);
 evas_object_clip_set(obj, clipper);
 evas_object_show(clipper);

.fi
.PP
 
.PP
References evas_damage_rectangle_add(), evas_event_feed_mouse_move(), evas_object_clip_unset(), and evas_object_type_get().
.SS "EAPI void evas_object_clip_unset (\fBEvas_Object\fP * obj)"
.PP
Disable clipping for an object. \fBParameters:\fP
.RS 4
\fIobj\fP The object to cease clipping on
.RE
.PP
This function disables clipping for the object \fCobj\fP, if it was already clipped. If it wasn't, this has no effect. The object \fCobj\fP must be a valid object.
.PP
See also \fBevas_object_clip_set()\fP, \fBevas_object_clipees_get()\fP and \fBevas_object_clip_get()\fP.
.PP
Example: 
.PP
.nf
 extern Evas_Object *obj;
 Evas_Object *clipper;

 clipper = evas_object_clip_get(obj);
 if (clipper)
   {
     evas_object_clip_unset(obj);
     evas_object_hide(obj);
   }

.fi
.PP
 
.PP
References evas_damage_rectangle_add(), and evas_event_feed_mouse_move().
.PP
Referenced by evas_object_clip_set(), and evas_object_del().
.SS "EAPI const Eina_List* evas_object_clipees_get (const \fBEvas_Object\fP * obj)"
.PP
Return a list of objects currently clipped by a specific object. \fBParameters:\fP
.RS 4
\fIobj\fP The object to get a list of clippees from
.RE
.PP
This returns the inernal list handle that contains all objects clipped by the object \fCobj\fP. If none are clipped, it returns NULL. This list is only valid until the clip list is changed and should be fetched again with another call to \fBevas_object_clipees_get()\fP if any objects being clipped by this object are unclipped, clipped by a new object, are deleted or the clipper is deleted. These operations will invalidate the list returned so it should not be used anymore after that point. Any use of the list after this may have undefined results, not limited just to strange behavior but possible segfaults and other strange memory errors. The object \fCobj\fP must be a valid object.
.PP
See also \fBevas_object_clip_set()\fP, \fBevas_object_clip_unset()\fP and \fBevas_object_clip_get()\fP.
.PP
Example: 
.PP
.nf
 extern Evas_Object *obj;
 Evas_Object *clipper;

 clipper = evas_object_clip_get(obj);
 if (clipper)
   {
     Eina_List *clippees, *l;
     Evas_Object *obj_tmp;

     clippees = evas_object_clipees_get(clipper);
     printf('Clipper clips %i objects\n', eina_list_count(clippees));
     EINA_LIST_FOREACH(clippees, l, obj_tmp)
         evas_object_show(obj_tmp);
   }

.fi
.PP
 
.SS "EAPI void evas_object_color_get (const \fBEvas_Object\fP * obj, int * r, int * g, int * b, int * a)"
.PP
Retrieves the general colour of the given evas object. Note that if any of \fCr\fP, \fCg\fP, \fCb\fP or \fCa\fP are \fCNULL\fP, then the \fCNULL\fP parameters are ignored.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.br
\fIr\fP Pointer to an integer in which to store the red component of the colour. 
.br
\fIg\fP Pointer to an integer in which to store the green component of the colour. 
.br
\fIb\fP Pointer to an integer in which to store the blue component of the colour. 
.br
\fIa\fP Pointer to an integer in which to store the alpha component of the colour. 
.RE
.PP

.SS "EAPI void evas_object_color_set (\fBEvas_Object\fP * obj, int r, int g, int b, int a)"
.PP
Sets the general colour of the given evas object to the given colour. \fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.br
\fIr\fP The red component of the given colour. 
.br
\fIg\fP The green component of the given colour. 
.br
\fIb\fP The blue component of the given colour. 
.br
\fIa\fP The alpha component of the given colour. 
.RE
.PP

.PP
References EVAS_RENDER_BLEND.
.SS "EAPI void evas_object_del (\fBEvas_Object\fP * obj)"
.PP
Deletes the given evas object and frees its memory. The object's 'free' callback is called when this function is called. If the object currently has the focus, its 'focus out' callback is also called.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.RE
.PP

.PP
References EVAS_CALLBACK_DEL, EVAS_CALLBACK_FOCUS_OUT, EVAS_CALLBACK_FREE, evas_object_clip_unset(), evas_object_hide(), evas_object_image_source_unset(), and evas_object_name_set().
.PP
Referenced by evas_object_box_remove_all(), evas_object_table_clear(), and evas_object_unref().
.SS "EAPI \fBEvas\fP* evas_object_evas_get (const \fBEvas_Object\fP * obj)"
.PP
Retrieves the evas that the given evas object is on. \fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.RE
.PP
\fBReturns:\fP
.RS 4
The evas that the object is on. 
.RE
.PP

.PP
Referenced by evas_object_box_add_to(), and evas_object_table_add_to().
.SS "EAPI Eina_Bool evas_object_focus_get (const \fBEvas_Object\fP * obj)"
.PP
Test if the object has focus. \fBParameters:\fP
.RS 4
\fIobj\fP The object to be tested.
.RE
.PP
If the passed object is the currently focused object 1 is returned, 0 otherwise.
.PP
\fBSee also:\fP
.RS 4
\fBevas_object_focus_set\fP 
.PP
\fBevas_focus_get\fP 
.PP
evas_object_key_grab 
.PP
evas_object_key_ungrab
.RE
.PP
\fBReturns:\fP
.RS 4
1 if the object has the focus, 0 otherwise. 
.RE
.PP

.SS "EAPI void evas_object_focus_set (\fBEvas_Object\fP * obj, Eina_Bool focus)"
.PP
Sets focus to the given object. \fBParameters:\fP
.RS 4
\fIobj\fP The object to be focused or unfocused. 
.br
\fIfocus\fP set or remove focus to the object.
.RE
.PP
Changing focus only affects where key events go. There can be only one object focused at any time. 
.PP
If the parameter (\fCfocus\fP) is set, the passed object will be set as the currently focused object. It will receive all keyboard events that are not exclusive key grabs on other objects.
.PP
\fBSee also:\fP
.RS 4
\fBevas_object_focus_get\fP 
.PP
\fBevas_focus_get\fP 
.PP
evas_object_key_grab 
.PP
evas_object_key_ungrab 
.RE
.PP

.PP
References EVAS_CALLBACK_CANVAS_OBJECT_FOCUS_IN, EVAS_CALLBACK_CANVAS_OBJECT_FOCUS_OUT, EVAS_CALLBACK_FOCUS_IN, EVAS_CALLBACK_FOCUS_OUT, and evas_object_focus_set().
.PP
Referenced by evas_object_focus_set().
.SS "EAPI void evas_object_geometry_get (const \fBEvas_Object\fP * obj, Evas_Coord * x, Evas_Coord * y, Evas_Coord * w, Evas_Coord * h)"
.PP
Retrieves the position and rectangular size of the given evas object. Note that if any of \fCx\fP, \fCy\fP, \fCw\fP or \fCh\fP are \fCNULL\fP, the \fCNULL\fP parameters are ignored.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.br
\fIx\fP Pointer to an integer in which to store the X coordinate of the object. 
.br
\fIy\fP Pointer to an integer in which to store the Y coordinate of the object. 
.br
\fIw\fP Pointer to an integer in which to store the width of the object. 
.br
\fIh\fP Pointer to an integer in which to store the height of the object. 
.RE
.PP

.PP
Referenced by evas_object_box_layout_flow_horizontal(), evas_object_box_layout_flow_vertical(), evas_object_box_layout_homogeneous_horizontal(), evas_object_box_layout_homogeneous_max_size_horizontal(), evas_object_box_layout_homogeneous_max_size_vertical(), evas_object_box_layout_homogeneous_vertical(), evas_object_box_layout_horizontal(), evas_object_box_layout_stack(), evas_object_box_layout_vertical(), and evas_object_image_filled_set().
.SS "EAPI void evas_object_hide (\fBEvas_Object\fP * obj)"
.PP
Makes the given evas object invisible. \fBParameters:\fP
.RS 4
\fIobj\fP The given evas object.
.RE
.PP
\fBNote:\fP
.RS 4
the hidden objects will not be checked for changes and will not catch events. That is, they are much ligher than an object that is invisible due indirect effects, such as clipped or out-of-viewport. 
.RE
.PP

.PP
References _Evas_Event_Mouse_Out::buttons, EVAS_CALLBACK_MOUSE_OUT, and evas_event_feed_mouse_move().
.PP
Referenced by evas_object_del().
.SS "EAPI short evas_object_layer_get (const \fBEvas_Object\fP * obj)"
.PP
Retrieves the layer of the evas that the given object is part of. Be careful, it doesn't make sense to change the layer of smart object's child. So the returned value could be wrong in some case. Don't rely on it's accuracy.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of the layer. 
.RE
.PP

.SS "EAPI void evas_object_layer_set (\fBEvas_Object\fP * obj, short l)"
.PP
Sets the layer of the evas that the given object will be part of. It is not possible to change the layer of a smart object's child.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.br
\fIl\fP The number of the layer to place the object on. Between \fBEVAS_LAYER_MIN\fP and \fBEVAS_LAYER_MAX\fP. 
.RE
.PP

.PP
References evas_event_feed_mouse_move(), and evas_object_raise().
.SS "EAPI void evas_object_lower (\fBEvas_Object\fP * obj)"
.PP
Lower \fCobj\fP to the bottom of its layer. \fBParameters:\fP
.RS 4
\fIobj\fP the object to lower 
.RE
.PP

.PP
References evas_event_feed_mouse_move().
.PP
Referenced by evas_object_stack_below().
.SS "EAPI void evas_object_move (\fBEvas_Object\fP * obj, Evas_Coord x, Evas_Coord y)"
.PP
Moves the given evas object to the given location. \fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.br
\fIx\fP X position to move the object to, in canvas units. 
.br
\fIy\fP Y position to move the object to, in canvas units. 
.RE
.PP

.PP
References evas_event_feed_mouse_move().
.PP
Referenced by evas_object_box_layout_flow_horizontal(), evas_object_box_layout_flow_vertical(), evas_object_box_layout_homogeneous_horizontal(), evas_object_box_layout_homogeneous_max_size_horizontal(), evas_object_box_layout_homogeneous_max_size_vertical(), evas_object_box_layout_homogeneous_vertical(), evas_object_box_layout_horizontal(), evas_object_box_layout_stack(), evas_object_box_layout_vertical(), and evas_object_smart_move_children_relative().
.SS "EAPI const char* evas_object_name_get (const \fBEvas_Object\fP * obj)"
.PP
Retrieves the name of the given evas object. \fBParameters:\fP
.RS 4
\fIobj\fP The given object. 
.RE
.PP
\fBReturns:\fP
.RS 4
The name of the object. \fCNULL\fP if no name has been given to the object. 
.RE
.PP

.SS "EAPI void evas_object_name_set (\fBEvas_Object\fP * obj, const char * name)"
.PP
Sets the name of the given evas object to the given name. \fBParameters:\fP
.RS 4
\fIobj\fP The given object. 
.br
\fIname\fP The given name. 
.RE
.PP

.PP
Referenced by evas_object_del().
.SS "EAPI void evas_object_raise (\fBEvas_Object\fP * obj)"
.PP
Raise \fCobj\fP to the top of its layer. \fBParameters:\fP
.RS 4
\fIobj\fP the object to raise 
.RE
.PP

.PP
References evas_event_feed_mouse_move().
.PP
Referenced by evas_object_layer_set(), and evas_object_stack_above().
.SS "EAPI void evas_object_ref (\fBEvas_Object\fP * obj)"
.PP
Increments object reference count to defer deletion. This increments the reference count of an object, which if greater than 0 will defer deletion by \fBevas_object_del()\fP until all references are released back to 0. References cannot go below 0 and unreferencing more times that referencing will result in the reference count being limited to 0. References are limited to 2^32 - 1 for an object. Referencing it more than this will result in it being limited to this value.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP The given evas object to reference
.RE
.PP
\fBSince:\fP
.RS 4
1.1.0 
.RE
.PP

.SS "EAPI void evas_object_resize (\fBEvas_Object\fP * obj, Evas_Coord w, Evas_Coord h)"
.PP
Changes the size of the given evas object. \fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.br
\fIw\fP The new width of the evas object. 
.br
\fIh\fP The new height of the evas object.
.RE
.PP
\fBNote:\fP
.RS 4
Be aware that resizing an object changes its drawing area, but that does imply the object is rescaled! For instance, images are filled inside their drawing area using the specifications of \fBevas_object_image_fill_set()\fP, thus to scale the image to match exactly your drawing area, you need to change the \fBevas_object_image_fill_set()\fP as well. Consider the following example: 
.PP
.nf
       // rescale image to fill exactly its area without tiling:
       evas_object_resize(img, w, h);
       evas_object_image_fill_set(img, 0, 0, w, h);

.fi
.PP
 This is more evident in images, but text, textblock, lines and polygons will behave similarly. Check their specific APIs to know how to achieve your desired behavior. 
.RE
.PP

.PP
References evas_event_feed_mouse_move().
.PP
Referenced by evas_object_box_layout_homogeneous_horizontal(), evas_object_box_layout_homogeneous_max_size_horizontal(), evas_object_box_layout_homogeneous_max_size_vertical(), evas_object_box_layout_homogeneous_vertical(), evas_object_box_layout_horizontal(), evas_object_box_layout_stack(), and evas_object_box_layout_vertical().
.SS "EAPI void evas_object_show (\fBEvas_Object\fP * obj)"
.PP
Makes the given evas object visible. \fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.RE
.PP

.PP
References evas_event_feed_mouse_move().
.SS "EAPI void evas_object_stack_above (\fBEvas_Object\fP * obj, \fBEvas_Object\fP * above)"
.PP
Stack \fCobj\fP immediately above \fCabove\fP. If \fCobj\fP is a member of a smart object, then \fCabove\fP must also be a member of the same smart object.
.PP
Similarly, if \fCobj\fP is not a member of smart object, \fCabove\fP may not either.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to stack 
.br
\fIabove\fP the object above which to stack 
.RE
.PP

.PP
References evas_event_feed_mouse_move(), and evas_object_raise().
.PP
Referenced by evas_object_box_layout_stack().
.SS "EAPI void evas_object_stack_below (\fBEvas_Object\fP * obj, \fBEvas_Object\fP * below)"
.PP
Stack \fCobj\fP immediately below \fCbelow\fP. If \fCobj\fP is a member of a smart object, then \fCbelow\fP must also be a member of the same smart object.
.PP
Similarly, if \fCobj\fP is not a member of smart object, \fCbelow\fP may not either.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP the object to stack 
.br
\fIbelow\fP the object below which to stack 
.RE
.PP

.PP
References evas_event_feed_mouse_move(), and evas_object_lower().
.SS "EAPI const char* evas_object_type_get (const \fBEvas_Object\fP * obj)"
.PP
Retrieves the name of the type of the given evas object. \fBParameters:\fP
.RS 4
\fIobj\fP The given object. 
.RE
.PP
\fBReturns:\fP
.RS 4
The name. 
.RE
.PP

.PP
Referenced by evas_object_clip_set().
.SS "EAPI void evas_object_unref (\fBEvas_Object\fP * obj)"
.PP
Decrements object reference count to defer deletion. This decrements the reference count of an object. If the object has had \fBevas_object_del()\fP called on it while references were more than 0, it will be deleted at the time this function is called as it normally would have been. See \fBevas_object_ref()\fP for more information.
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP The given evas object to unreference
.RE
.PP
\fBSince:\fP
.RS 4
1.1.0 
.RE
.PP

.PP
References evas_object_del().
.SS "EAPI Eina_Bool evas_object_visible_get (const \fBEvas_Object\fP * obj)"
.PP
Retrieves whether or not the given evas object is visible. \fBParameters:\fP
.RS 4
\fIobj\fP The given evas object. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fC1\fP if the object is visible. \fC0\fP otherwise. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Evas from the source code.
