.TH "Object Events" 3 "Tue Apr 19 2011" "Evas" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Object Events \- 
.PP
Objects generates events when they are moved, resized, when their visibility change, when they are deleted and so on.  

.SS "Functions"

.in +1c
.ti -1c
.RI "EAPI void \fBevas_object_event_callback_add\fP (\fBEvas_Object\fP *obj, \fBEvas_Callback_Type\fP type, Evas_Object_Event_Cb func, const void *data)"
.br
.RI "\fIAdd a callback function to an object. \fP"
.ti -1c
.RI "EAPI void * \fBevas_object_event_callback_del\fP (\fBEvas_Object\fP *obj, \fBEvas_Callback_Type\fP type, Evas_Object_Event_Cb func)"
.br
.RI "\fIDelete a callback function from an object. \fP"
.ti -1c
.RI "EAPI void * \fBevas_object_event_callback_del_full\fP (\fBEvas_Object\fP *obj, \fBEvas_Callback_Type\fP type, Evas_Object_Event_Cb func, const void *data)"
.br
.RI "\fIDelete a callback function from an object. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_pass_events_set\fP (\fBEvas_Object\fP *obj, Eina_Bool pass)"
.br
.RI "\fISet an object's pass events state. \fP"
.ti -1c
.RI "EAPI Eina_Bool \fBevas_object_pass_events_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIDetermine whether an object is set to pass events. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_repeat_events_set\fP (\fBEvas_Object\fP *obj, Eina_Bool repeat)"
.br
.RI "\fISet an object's repeat events state. \fP"
.ti -1c
.RI "EAPI Eina_Bool \fBevas_object_repeat_events_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIDetermine whether an object is set to repeat events. \fP"
.ti -1c
.RI "EAPI void \fBevas_object_propagate_events_set\fP (\fBEvas_Object\fP *obj, Eina_Bool prop)"
.br
.RI "\fISet whether events on a smart member object should propagate to its parent. \fP"
.ti -1c
.RI "EAPI Eina_Bool \fBevas_object_propagate_events_get\fP (const \fBEvas_Object\fP *obj)"
.br
.RI "\fIDetermine whether an object is set to propagate events. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Objects generates events when they are moved, resized, when their visibility change, when they are deleted and so on. 

These methods will allow one to handle such events.
.PP
The events can be those from keyboard and mouse, if the object accepts these events. 
.SH "Function Documentation"
.PP 
.SS "EAPI void evas_object_event_callback_add (\fBEvas_Object\fP * obj, \fBEvas_Callback_Type\fP type, Evas_Object_Event_Cb func, const void * data)"
.PP
Add a callback function to an object. \fBParameters:\fP
.RS 4
\fIobj\fP Object to attach a callback to 
.br
\fItype\fP The type of event that will trigger the callback 
.br
\fIfunc\fP The function to be called when the event is triggered 
.br
\fIdata\fP The data pointer to be passed to \fCfunc\fP 
.RE
.PP
This function adds a function callback to an object when the event of type \fCtype\fP occurs on object \fCobj\fP. The function is \fCfunc\fP.
.PP
In the event of a memory allocation error during addition of the callback to the object, \fBevas_alloc_error()\fP should be used to determine the nature of the error, if any, and the program should sensibly try and recover.
.PP
The function will be passed the pointer \fCdata\fP when it is called. A callback function must look like this:
.PP
.PP
.nf
 void callback (void *data, Evas *e, Evas_Object *obj, void *event_info);
.fi
.PP
.PP
The first parameter \fCdata\fP in this function will be the same value passed to \fBevas_object_event_callback_add()\fP as the \fCdata\fP parameter. The second parameter is a convenience for the programmer to know what evas canvas the event occurred on. The third parameter \fCobj\fP is the Object handle on which the event occurred. The foruth parameter \fCevent_info\fP is a pointer to a data structure that may or may not be passed to the callback, depending on the event type that triggered the callback.
.PP
The event type \fCtype\fP to trigger the function may be one of \fBEVAS_CALLBACK_MOUSE_IN\fP, \fBEVAS_CALLBACK_MOUSE_OUT\fP, \fBEVAS_CALLBACK_MOUSE_DOWN\fP, \fBEVAS_CALLBACK_MOUSE_UP\fP, \fBEVAS_CALLBACK_MOUSE_MOVE\fP, \fBEVAS_CALLBACK_MOUSE_WHEEL\fP, \fBEVAS_CALLBACK_FREE\fP, \fBEVAS_CALLBACK_KEY_DOWN\fP, \fBEVAS_CALLBACK_KEY_UP\fP, \fBEVAS_CALLBACK_FOCUS_IN\fP, \fBEVAS_CALLBACK_FOCUS_OUT\fP, \fBEVAS_CALLBACK_SHOW\fP, \fBEVAS_CALLBACK_HIDE\fP, \fBEVAS_CALLBACK_MOVE\fP, \fBEVAS_CALLBACK_RESIZE\fP or \fBEVAS_CALLBACK_RESTACK\fP. This determines the kind of event that will trigger the callback to be called. The \fCevent_info\fP pointer passed to the callback will be one of the following, depending on the event triggering it:
.PP
\fBEVAS_CALLBACK_MOUSE_IN\fP: event_info = pointer to Evas_Event_Mouse_In
.PP
This event is triggered when the mouse pointer enters the region of the object \fCobj\fP. This may occur by the mouse pointer being moved by \fBevas_event_feed_mouse_move()\fP or evas_event_feed_mouse_move_data() calls, or by the object being shown, raised, moved, resized, or other objects being moved out of the way, hidden, lowered or moved out of the way.
.PP
\fBEVAS_CALLBACK_MOUSE_OUT\fP: event_info = pointer to Evas_Event_Mouse_Out
.PP
This event is triggered exactly like \fBEVAS_CALLBACK_MOUSE_IN\fP is, but occurs when the mouse pointer exits an object. Note that no out events will be reported if the mouse pointer is implicitly grabbed to an object (the mouse buttons are down at all and any were pressed on that object). An out event will be reported as soon as the mouse is no longer grabbed (no mouse buttons are depressed). Out events will be reported once all buttons are released, if the mouse has left the object.
.PP
\fBEVAS_CALLBACK_MOUSE_DOWN\fP: event_info = pointer to Evas_Event_Mouse_Down
.PP
This event is triggered by a mouse button being depressed while over an object. If pointermode is EVAS_OBJECT_POINTER_MODE_AUTOGRAB (default) this causes this object to passively grab the mouse until all mouse buttons have been released. That means if this mouse button is the first to be pressed, all future mouse events will be reported to only this object until no buttons are down. That includes mouse move events, in and out events, and further button presses. When all buttons are released, event propagation occurs as normal.
.PP
\fBEVAS_CALLBACK_MOUSE_UP\fP: event_info = pointer to Evas_Event_Mouse_Up
.PP
This event is triggered by a mouse button being released while over an object or when passively grabbed to an object. If this is the last mouse button to be raised on an object then the passive grab is released and event processing will continue as normal.
.PP
\fBEVAS_CALLBACK_MOUSE_MOVE\fP: event_info = pointer to Evas_Event_Mouse_Move
.PP
This event is triggered by the mouse pointer moving while over an object or passively grabbed to an object.
.PP
\fBEVAS_CALLBACK_MOUSE_WHEEL\fP: event_info = pointer to Evas_Event_Mouse_Wheel
.PP
This event is triggered by the mouse wheel being rolled while over an object or passively grabbed to an object.
.PP
\fBEVAS_CALLBACK_FREE\fP: event_info = NULL
.PP
This event is triggered just before Evas is about to free all memory used by an object and remove all references to it. This is useful for programs to use if they attached data to an object and want to free it when the object is deleted. The object is still valid when this callback is called, but after this callback returns, there is no guarantee on the object's validity.
.PP
\fBEVAS_CALLBACK_KEY_DOWN\fP: event_info = pointer to Evas_Event_Key_Down
.PP
This callback is called when a key is pressed and the focus is on the object, or a key has been grabbed to a particular object which wants to intercept the key press regardless of what object has the focus.
.PP
\fBEVAS_CALLBACK_KEY_UP\fP: event_info = pointer to Evas_Event_Key_Up
.PP
This callback is called when a key is released and the focus is on the object, or a key has been grabbed to a particular object which wants to intercept the key release regardless of what object has the focus.
.PP
\fBEVAS_CALLBACK_FOCUS_IN\fP: event_info = NULL
.PP
This event is called when an object gains the focus. When the callback is called the object has already gained the focus.
.PP
\fBEVAS_CALLBACK_FOCUS_OUT\fP: event_info = NULL
.PP
This event is triggered by an object losing the focus. When the callback is called the object has already lost the focus.
.PP
\fBEVAS_CALLBACK_SHOW\fP: event_info = NULL
.PP
This event is triggered by the object being shown by \fBevas_object_show()\fP.
.PP
\fBEVAS_CALLBACK_HIDE\fP: event_info = NULL
.PP
This event is triggered by an object being hidden by \fBevas_object_hide()\fP.
.PP
\fBEVAS_CALLBACK_MOVE\fP: event_info = NULL
.PP
This event is triggered by an object being moved. \fBevas_object_move()\fP can trigger this, as can any object-specific manipulations that would mean the object's origin could move.
.PP
\fBEVAS_CALLBACK_RESIZE\fP: event_info = NULL
.PP
This event is triggered by an object being resized. Resizes can be triggered by \fBevas_object_resize()\fP or by any object-specific calls that may cause the object to resize.
.PP
Example: 
.PP
.nf
 extern Evas_Object *object;
 extern void *my_data;
 void down_callback(void *data, Evas *e, Evas_Object *obj, void *event_info);
 void up_callback(void *data, Evas *e, Evas_Object *obj, void *event_info);

 evas_object_event_callback_add(object, EVAS_CALLBACK_MOUSE_UP, up_callback, my_data);
 if (evas_alloc_error() != EVAS_ALLOC_ERROR_NONE)
   {
     fprintf(stderr, 'ERROR: Callback registering failed! Abort!\n');
     exit(-1);
   }
 evas_object_event_callback_add(object, EVAS_CALLBACK_MOUSE_DOWN, down_callback, my_data);
 if (evas_alloc_error() != EVAS_ALLOC_ERROR_NONE)
   {
     fprintf(stderr, 'ERROR: Callback registering failed! Abort!\n');
     exit(-1);
   }

.fi
.PP
 
.PP
Referenced by evas_object_image_filled_set().
.SS "EAPI void* evas_object_event_callback_del (\fBEvas_Object\fP * obj, \fBEvas_Callback_Type\fP type, Evas_Object_Event_Cb func)"
.PP
Delete a callback function from an object. \fBParameters:\fP
.RS 4
\fIobj\fP Object to remove a callback from 
.br
\fItype\fP The type of event that was triggering the callback 
.br
\fIfunc\fP The function that was to be called when the event was triggered 
.RE
.PP
\fBReturns:\fP
.RS 4
The data pointer that was to be passed to the callback
.RE
.PP
This function removes the most recently added callback from the object \fCobj\fP which was triggered by the event type \fCtype\fP and was calling the function \fCfunc\fP when triggered. If the removal is successful it will also return the data pointer that was passed to \fBevas_object_event_callback_add()\fP when the callback was added to the object. If not successful NULL will be returned.
.PP
Example: 
.PP
.nf
 extern Evas_Object *object;
 void *my_data;
 void up_callback(void *data, Evas *e, Evas_Object *obj, void *event_info);

 my_data = evas_object_event_callback_del(object, EVAS_CALLBACK_MOUSE_UP, up_callback);

.fi
.PP
 
.PP
Referenced by evas_object_image_filled_set().
.SS "EAPI void* evas_object_event_callback_del_full (\fBEvas_Object\fP * obj, \fBEvas_Callback_Type\fP type, Evas_Object_Event_Cb func, const void * data)"
.PP
Delete a callback function from an object. \fBParameters:\fP
.RS 4
\fIobj\fP Object to remove a callback from 
.br
\fItype\fP The type of event that was triggering the callback 
.br
\fIfunc\fP The function that was to be called when the event was triggered 
.br
\fIdata\fP The data pointer that was to be passed to the callback 
.RE
.PP
\fBReturns:\fP
.RS 4
The data pointer that was to be passed to the callback
.RE
.PP
This function removes the most recently added callback from the object \fCobj\fP which was triggered by the event type \fCtype\fP and was calling the function \fCfunc\fP with data \fCdata\fP when triggered. If the removal is successful it will also return the data pointer that was passed to \fBevas_object_event_callback_add()\fP (that will be the same as the parameter) when the callback was added to the object. If not successful NULL will be returned.
.PP
Example: 
.PP
.nf
 extern Evas_Object *object;
 void *my_data;
 void up_callback(void *data, Evas *e, Evas_Object *obj, void *event_info);

 my_data = evas_object_event_callback_del_full(object, EVAS_CALLBACK_MOUSE_UP, up_callback, data);

.fi
.PP
 
.SS "EAPI Eina_Bool evas_object_pass_events_get (const \fBEvas_Object\fP * obj)"
.PP
Determine whether an object is set to pass events. \fBParameters:\fP
.RS 4
\fIobj\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
pass events state 
.RE
.PP

.SS "EAPI void evas_object_pass_events_set (\fBEvas_Object\fP * obj, Eina_Bool pass)"
.PP
Set an object's pass events state. \fBParameters:\fP
.RS 4
\fIobj\fP the evas object 
.br
\fIpass\fP whether to pass events or not
.RE
.PP
If \fCpass\fP is true, this will cause events on \fCobj\fP to be ignored. They will be triggered on the next lower object (that is not set to pass events) instead.
.PP
If \fCpass\fP is false, events will be processed as normal. 
.PP
References evas_event_feed_mouse_move().
.SS "EAPI Eina_Bool evas_object_propagate_events_get (const \fBEvas_Object\fP * obj)"
.PP
Determine whether an object is set to propagate events. \fBParameters:\fP
.RS 4
\fIobj\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
propagate events state 
.RE
.PP

.SS "EAPI void evas_object_propagate_events_set (\fBEvas_Object\fP * obj, Eina_Bool prop)"
.PP
Set whether events on a smart member object should propagate to its parent. \fBParameters:\fP
.RS 4
\fIobj\fP the smart member object 
.br
\fIprop\fP wheter to propagate events or not
.RE
.PP
This function has no effect if \fCobj\fP is not a member of a smart object.
.PP
If \fCprop\fP is true, events occurring on this object will propagate on to the smart object of which \fCobj\fP is a member.
.PP
If \fCprop\fP is false, events for which callbacks are set on the member object, \fCobj\fP, will not be passed on to the parent smart object.
.PP
The default value is true. 
.SS "EAPI Eina_Bool evas_object_repeat_events_get (const \fBEvas_Object\fP * obj)"
.PP
Determine whether an object is set to repeat events. \fBParameters:\fP
.RS 4
\fIobj\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
repeat events state 
.RE
.PP

.SS "EAPI void evas_object_repeat_events_set (\fBEvas_Object\fP * obj, Eina_Bool repeat)"
.PP
Set an object's repeat events state. \fBParameters:\fP
.RS 4
\fIobj\fP the object 
.br
\fIrepeat\fP wheter to repeat events or not
.RE
.PP
If \fCrepeat\fP is true, this will cause events on \fCobj\fP to trigger callbacks, but also to be repeated on the next lower object in the stack.
.PP
If \fCrepeat\fP is false, events occurring on \fCobj\fP will be processed normally. 
.PP
References evas_event_feed_mouse_move().
.SH "Author"
.PP 
Generated automatically by Doxygen for Evas from the source code.
