.TH "Smart Functions" 3 "Tue Apr 19 2011" "Evas" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Smart Functions \- 
.PP
Functions that deal with Evas_Smart's, creating definition (classes) of objects that will have customized behavior for methods like \fBevas_object_move()\fP, \fBevas_object_resize()\fP, \fBevas_object_clip_set()\fP and others.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_Evas_Smart_Class\fP"
.br
.RI "\fIa smart object class \fP"
.ti -1c
.RI "struct \fB_Evas_Smart_Cb_Description\fP"
.br
.RI "\fIDescribes a callback used by a smart class \fBevas_object_smart_callback_call()\fP, particularly useful to explain to user and its code (ie: introspection) what the parameter \fCevent_info\fP will contain. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBEVAS_SMART_CLASS_VERSION\fP   4"
.br
.RI "\fIThe version you have to put into the version field in the smart class struct. \fP"
.ti -1c
.RI "#define \fBEVAS_SMART_CLASS_INIT_NULL\fP   {NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}"
.br
.RI "\fIInitializer to zero a whole Evas_Smart_Class structure. \fP"
.ti -1c
.RI "#define \fBEVAS_SMART_CLASS_INIT_VERSION\fP   {NULL, EVAS_SMART_CLASS_VERSION, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}"
.br
.RI "\fIInitializer to zero a whole Evas_Smart_Class structure and set version. \fP"
.ti -1c
.RI "#define \fBEVAS_SMART_CLASS_INIT_NAME_VERSION\fP(name)   {name, EVAS_SMART_CLASS_VERSION, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}"
.br
.RI "\fIInitializer to zero a whole Evas_Smart_Class structure and set name and version. \fP"
.ti -1c
.RI "#define \fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT\fP(name, parent)   {name, EVAS_SMART_CLASS_VERSION, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, parent, NULL, NULL}"
.br
.RI "\fIInitializer to zero a whole Evas_Smart_Class structure and set name, version and parent class. \fP"
.ti -1c
.RI "#define \fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS\fP(name, parent, callbacks)   {name, EVAS_SMART_CLASS_VERSION, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, parent, callbacks, NULL}"
.br
.RI "\fIInitializer to zero a whole Evas_Smart_Class structure and set name, version, parent class and callbacks definition. \fP"
.ti -1c
.RI "#define \fBEVAS_SMART_SUBCLASS_NEW\fP(smart_name, prefix, api_type, parent_type, parent_func, cb_desc)"
.br
.RI "\fIConvenience macro to subclass a Smart Class. \fP"
.ti -1c
.RI "#define \fBEVAS_SMART_DATA_ALLOC\fP(o, priv_type)"
.br
.RI "\fIConvenience macro to allocate smart data only if needed. \fP"
.ti -1c
.RI "#define \fBevas_smart_class_inherit\fP(sc, parent_sc)   evas_smart_class_inherit_full(sc, parent_sc, sizeof(*parent_sc))"
.br
.RI "\fIEasy to use version of \fBevas_smart_class_inherit_full()\fP. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_Evas_Smart_Class\fP \fBEvas_Smart_Class\fP"
.br
.RI "\fIA smart object base class. \fP"
.ti -1c
.RI "typedef struct \fB_Evas_Smart_Cb_Description\fP \fBEvas_Smart_Cb_Description\fP"
.br
.RI "\fIA smart object callback description, used to provide introspection. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "EAPI void \fBevas_smart_free\fP (\fBEvas_Smart\fP *s)"
.br
.RI "\fIFree an Evas_Smart. \fP"
.ti -1c
.RI "EAPI \fBEvas_Smart\fP * \fBevas_smart_class_new\fP (const \fBEvas_Smart_Class\fP *sc)"
.br
.RI "\fICreates an Evas_Smart from an Evas_Smart_Class. \fP"
.ti -1c
.RI "EAPI const \fBEvas_Smart_Class\fP * \fBevas_smart_class_get\fP (const \fBEvas_Smart\fP *s)"
.br
.RI "\fIGet the Evas_Smart_Class of an Evas_Smart. \fP"
.ti -1c
.RI "EAPI void * \fBevas_smart_data_get\fP (const \fBEvas_Smart\fP *s)"
.br
.RI "\fIGet the data pointer set on an Evas_Smart. \fP"
.ti -1c
.RI "EAPI const \fBEvas_Smart_Cb_Description\fP ** \fBevas_smart_callbacks_descriptions_get\fP (const \fBEvas_Smart\fP *s, unsigned int *count)"
.br
.RI "\fIGet the callbacks known by this Evas_Smart. \fP"
.ti -1c
.RI "EAPI const \fBEvas_Smart_Cb_Description\fP * \fBevas_smart_callback_description_find\fP (const \fBEvas_Smart\fP *s, const char *name)"
.br
.RI "\fIFind callback description for callback called \fIname\fP. \fP"
.ti -1c
.RI "EAPI Eina_Bool \fBevas_smart_class_inherit_full\fP (\fBEvas_Smart_Class\fP *sc, const \fBEvas_Smart_Class\fP *parent_sc, unsigned int parent_sc_size)"
.br
.RI "\fISets one class to inherit from the other. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Functions that deal with Evas_Smart's, creating definition (classes) of objects that will have customized behavior for methods like \fBevas_object_move()\fP, \fBevas_object_resize()\fP, \fBevas_object_clip_set()\fP and others. 

These objects will accept the generic methods defined in \fBGeneric Object Functions\fP and the extensions defined in \fBSmart Object Functions\fP. There are couple of existent smart objects in Evas itself, see \fBBox (Sequence) Smart Object.\fP, \fBTable Smart Object.\fP and \fBClipped Smart Object\fP. 
.SH "Define Documentation"
.PP 
.SS "#define evas_smart_class_inherit(sc, parent_sc)   evas_smart_class_inherit_full(sc, parent_sc, sizeof(*parent_sc))"
.PP
Easy to use version of \fBevas_smart_class_inherit_full()\fP. This version will use sizeof(parent_sc), copying everything.
.PP
\fBParameters:\fP
.RS 4
\fIsc\fP child class, will have methods copied from \fIparent_sc\fP 
.br
\fIparent_sc\fP parent class, will provide contents to be copied. 
.RE
.PP
\fBReturns:\fP
.RS 4
1 on success, 0 on failure. 
.RE
.PP

.SS "#define EVAS_SMART_CLASS_INIT_NAME_VERSION(name)   {name, EVAS_SMART_CLASS_VERSION, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}"
.PP
Initializer to zero a whole Evas_Smart_Class structure and set name and version. Similar to EVAS_SMART_CLASS_INIT_NULL, but will set version field to latest EVAS_SMART_CLASS_VERSION and name to the specified value.
.PP
It will keep a reference to name field as a 'const char *', that is, name must be available while the structure is used (hint: static or global!) and will not be modified.
.PP
\fBSee also:\fP
.RS 4
\fBEVAS_SMART_CLASS_INIT_NULL\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_VERSION\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS\fP 
.RE
.PP

.PP
Referenced by evas_object_smart_clipped_class_get().
.SS "#define EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT(name, parent)   {name, EVAS_SMART_CLASS_VERSION, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, parent, NULL, NULL}"
.PP
Initializer to zero a whole Evas_Smart_Class structure and set name, version and parent class. Similar to EVAS_SMART_CLASS_INIT_NULL, but will set version field to latest EVAS_SMART_CLASS_VERSION, name to the specified value and parent class.
.PP
It will keep a reference to name field as a 'const char *', that is, name must be available while the structure is used (hint: static or global!) and will not be modified. Similarly, parent reference will be kept.
.PP
\fBSee also:\fP
.RS 4
\fBEVAS_SMART_CLASS_INIT_NULL\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_VERSION\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS\fP 
.RE
.PP

.SS "#define EVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS(name, parent, callbacks)   {name, EVAS_SMART_CLASS_VERSION, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, parent, callbacks, NULL}"
.PP
Initializer to zero a whole Evas_Smart_Class structure and set name, version, parent class and callbacks definition. Similar to EVAS_SMART_CLASS_INIT_NULL, but will set version field to latest EVAS_SMART_CLASS_VERSION, name to the specified value, parent class and callbacks at this level.
.PP
It will keep a reference to name field as a 'const char *', that is, name must be available while the structure is used (hint: static or global!) and will not be modified. Similarly, parent and callbacks reference will be kept.
.PP
\fBSee also:\fP
.RS 4
\fBEVAS_SMART_CLASS_INIT_NULL\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_VERSION\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT\fP 
.RE
.PP

.SS "#define EVAS_SMART_CLASS_INIT_NULL   {NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}"
.PP
Initializer to zero a whole Evas_Smart_Class structure. \fBSee also:\fP
.RS 4
\fBEVAS_SMART_CLASS_INIT_VERSION\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS\fP 
.RE
.PP

.SS "#define EVAS_SMART_CLASS_INIT_VERSION   {NULL, EVAS_SMART_CLASS_VERSION, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}"
.PP
Initializer to zero a whole Evas_Smart_Class structure and set version. Similar to EVAS_SMART_CLASS_INIT_NULL, but will set version field to latest EVAS_SMART_CLASS_VERSION.
.PP
\fBSee also:\fP
.RS 4
\fBEVAS_SMART_CLASS_INIT_NULL\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT\fP 
.PP
\fBEVAS_SMART_CLASS_INIT_NAME_VERSION_PARENT_CALLBACKS\fP 
.RE
.PP

.SS "#define EVAS_SMART_DATA_ALLOC(o, priv_type)"\fBValue:\fP
.PP
.nf
priv_type *priv; \
   priv = evas_object_smart_data_get(o); \
   if (!priv) { \
      priv = (priv_type *)calloc(1, sizeof(priv_type)); \
      if (!priv) return; \
      evas_object_smart_data_set(o, priv); \
   }
.fi
.PP
Convenience macro to allocate smart data only if needed. When writing a subclassable smart object, the .add function will need to check if the smart private data was already allocated by some child object or not. This macro makes it easier to do it.
.PP
\fBParameters:\fP
.RS 4
\fIo\fP Evas object passed to the .add function 
.br
\fIpriv_type\fP The type of the data to allocate 
.RE
.PP

.SS "#define EVAS_SMART_SUBCLASS_NEW(smart_name, prefix, api_type, parent_type, parent_func, cb_desc)"\fBValue:\fP
.PP
.nf
static const parent_type * prefix##_parent_sc = NULL;                   \
  static void prefix##_smart_set_user(api_type *api);                   \
  static void prefix##_smart_set(api_type *api)                         \
  {                                                                     \
     Evas_Smart_Class *sc;                                              \
     if (!(sc = (Evas_Smart_Class *)api))                               \
       return;                                                          \
     if (!prefix##_parent_sc)                                           \
       prefix##_parent_sc = parent_func();                              \
     evas_smart_class_inherit(sc, (const Evas_Smart_Class *)prefix##_parent_sc); \
     prefix##_smart_set_user(api);                                      \
  }                                                                     \
  static Evas_Smart * prefix##_smart_class_new(void)                    \
  {                                                                     \
     static Evas_Smart *smart = NULL;                                   \
     static api_type api;                                               \
     if (!smart)                                                        \
       {                                                                \
          Evas_Smart_Class *sc = (Evas_Smart_Class *)&api;              \
          memset(&api, 0, sizeof(api_type));                            \
          sc->version = EVAS_SMART_CLASS_VERSION;                       \
          sc->name = smart_name;                                        \
          sc->callbacks = cb_desc;                                      \
          prefix##_smart_set(&api);                                     \
          smart = evas_smart_class_new(sc);                             \
       }                                                                \
     return smart;                                                      \
  }
.fi
.PP
Convenience macro to subclass a Smart Class. This macro saves some typing when writing a Smart Class derived from another one. In order to work, the user needs to provide some functions adhering to the following guidelines.
.IP "\(bu" 2
<prefix>_smart_set_user(): the internal _smart_set function will call this one provided by the user after inheriting everything from the parent, which should take care of setting the right member functions for the class.
.IP "\(bu" 2
<prefix>_parent_sc: pointer to the smart class of the parent. When calling parent functions from overloaded ones, use this global variable.
.IP "\(bu" 2
<prefix>_smart_class_new(): this function returns the Evas_Smart needed to create smart objects with this class, should be called by the public _add() function.
.IP "\(bu" 2
If this new class should be subclassable as well, a public _smart_set() function is desirable to fill the class used as parent by the children. It's up to the user to provide this interface, which will most likely call <prefix>_smart_set() to get the job done.
.PP
.PP
\fBParameters:\fP
.RS 4
\fIsmart_name\fP The name used for the Smart Class. e.g: 'Evas_Object_Box'. 
.br
\fIprefix\fP Prefix used for all variables and functions defined. 
.br
\fIapi_type\fP Type of the structure used as API for the Smart Class. Either Evas_Smart_Class or something derived from it. 
.br
\fIparent_type\fP Type of the parent class API. 
.br
\fIparent_func\fP Function that gets the parent class. e.g: \fBevas_object_box_smart_class_get()\fP. 
.br
\fIcb_desc\fP Array of callback descriptions for this Smart Class. 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "EAPI const \fBEvas_Smart_Cb_Description\fP* evas_smart_callback_description_find (const \fBEvas_Smart\fP * s, const char * name)"
.PP
Find callback description for callback called \fIname\fP. \fBParameters:\fP
.RS 4
\fIs\fP the Evas_Smart. 
.br
\fIname\fP name of desired callback, must \fBnot\fP be \fCNULL\fP. The search have a special case for \fIname\fP being the same pointer as registered with Evas_Smart_Cb_Description, one can use it to avoid excessive use of strcmp(). 
.RE
.PP
\fBReturns:\fP
.RS 4
reference to description if found, \fCNULL\fP if not found. 
.RE
.PP

.SS "EAPI const \fBEvas_Smart_Cb_Description\fP** evas_smart_callbacks_descriptions_get (const \fBEvas_Smart\fP * s, unsigned int * count)"
.PP
Get the callbacks known by this Evas_Smart. This is likely different from \fBEvas_Smart_Class::callbacks\fP as it will contain the callbacks of all class hierarchy sorted, while the direct smart class member refers only to that specific class and should not include parent's.
.PP
If no callbacks are known, this function returns \fCNULL\fP.
.PP
The array elements and thus their contents will be reference to original values given to evas_smart_new() as \fBEvas_Smart_Class::callbacks\fP.
.PP
The array is sorted by name. The last array element is the \fCNULL\fP pointer and is not counted in \fIcount\fP. Loop iterations can check any of these cases.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP the Evas_Smart. 
.br
\fIcount\fP returns the number of elements in returned array. 
.RE
.PP
\fBReturns:\fP
.RS 4
the array with callback descriptions known by this class, its size is returned in \fIcount\fP parameter. It should not be modified anyhow. If no callbacks are known, \fCNULL\fP is returned. The array is sorted by name and elements refer to the original value given to evas_smart_new().
.RE
.PP
\fBNote:\fP
.RS 4
objects may provide per-instance callbacks, use \fBevas_object_smart_callbacks_descriptions_get()\fP to get those as well. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBevas_object_smart_callbacks_descriptions_get()\fP 
.RE
.PP

.SS "EAPI const \fBEvas_Smart_Class\fP* evas_smart_class_get (const \fBEvas_Smart\fP * s)"
.PP
Get the Evas_Smart_Class of an Evas_Smart. \fBParameters:\fP
.RS 4
\fIs\fP the Evas_Smart 
.RE
.PP
\fBReturns:\fP
.RS 4
the Evas_Smart_Class 
.RE
.PP

.SS "EAPI Eina_Bool evas_smart_class_inherit_full (\fBEvas_Smart_Class\fP * sc, const \fBEvas_Smart_Class\fP * parent_sc, unsigned int parent_sc_size)"
.PP
Sets one class to inherit from the other. Copy all function pointers, set \fCparent\fP to \fIparent_sc\fP and copy everything after sizeof(Evas_Smart_Class) present in \fIparent_sc\fP, using \fIparent_sc_size\fP as reference.
.PP
This is recommended instead of a single memcpy() since it will take care to not modify \fIsc\fP name, version, callbacks and possible other members.
.PP
\fBParameters:\fP
.RS 4
\fIsc\fP child class. 
.br
\fIparent_sc\fP parent class, will provide attributes. 
.br
\fIparent_sc_size\fP size of parent_sc structure, child should be at least this size. Everything after \fCEvas_Smart_Class\fP size is copied using regular memcpy(). 
.RE
.PP

.PP
References EVAS_SMART_CLASS_VERSION, and _Evas_Smart_Class::parent.
.SS "EAPI \fBEvas_Smart\fP* evas_smart_class_new (const \fBEvas_Smart_Class\fP * sc)"
.PP
Creates an Evas_Smart from an Evas_Smart_Class. \fBParameters:\fP
.RS 4
\fIsc\fP the smart class definition 
.RE
.PP
\fBReturns:\fP
.RS 4
an Evas_Smart 
.RE
.PP

.PP
References EVAS_SMART_CLASS_VERSION.
.SS "EAPI void* evas_smart_data_get (const \fBEvas_Smart\fP * s)"
.PP
Get the data pointer set on an Evas_Smart. \fBParameters:\fP
.RS 4
\fIs\fP Evas_Smart
.RE
.PP
This data pointer is set either as the final parameter to evas_smart_new or as the data field in the Evas_Smart_Class passed in to evas_smart_class_new 
.SS "EAPI void evas_smart_free (\fBEvas_Smart\fP * s)"
.PP
Free an Evas_Smart. If this smart was created using \fBevas_smart_class_new()\fP, the associated Evas_Smart_Class will not be freed.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP the Evas_Smart to free 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Evas from the source code.
